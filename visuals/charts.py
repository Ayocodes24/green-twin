import pydeck as pdk
import pandas as pd
import numpy as np

def plot_network_pydeck(network_df, optimized_route_ids=[]):
    """
    Generates a PyDeck chart for the supply chain network, including nodes and
    an optional optimized route, using OpenStreetMap as a base map.
    """
    # Calculate initial view state
    if not network_df.empty:
        view_state = pdk.ViewState(
            latitude=network_df['lat'].mean(),
            longitude=network_df['lon'].mean(),
            zoom=1.5, # Adjusted for multi-country view
            pitch=45,
        )
    else:
        view_state = pdk.ViewState(latitude=0, longitude=0, zoom=1) # Default if no data

    # Create a DataFrame for optimized route lines
    route_data = []
    if optimized_route_ids and len(optimized_route_ids) > 1:
        # Create segments for the optimized route
        for i in range(len(optimized_route_ids) - 1):
            from_node = network_df[network_df['node_id'] == optimized_route_ids[i]].iloc[0]
            to_node = network_df[network_df['node_id'] == optimized_route_ids[i+1]].iloc[0]
            route_data.append({
                'path': [[from_node['lon'], from_node['lat']], [to_node['lon'], to_node['lat']]],
                'from_id': from_node['node_id'],
                'to_id': to_node['node_id']
            })
    
    # Define OpenStreetMap tile layer for the base map
    # This URL points to a standard OSM tile server.
    # You might need to experiment with different tile servers if this one is slow or has usage limits.
    osm_tile_layer = pdk.Layer(
        "BitmapLayer",
        data=[
            {
                "image": "https://a.tile.openstreetmap.org/{z}/{x}/{y}.png",
                "bounds": [-180, -85.05112878, 180, 85.05112878], # Global bounds
            }
        ],
        id="osm-base-map",
        opacity=0.8 # Adjust opacity as needed
    )

    # PyDeck Layers
    layers = [
        osm_tile_layer, # Add OSM base map as the first layer
        # Nodes Layer
        pdk.Layer(
            'ScatterplotLayer',
            data=network_df,
            get_position='[lon, lat]',
            get_color='[255, 0, 0, 160]' if network_df['type'].iloc[0] == 'dc' else '[255, 100, 100, 160]', # Red for DC, lighter red for stores
            get_radius=10000, # Radius in meters, adjusted for global view
            pickable=True,
            auto_highlight=True,
            tooltip={"text": "{name}\nType: {type}\nCountry: {country}"}
        )
    ]

    # Add Optimized Route Layer if available
    if route_data:
        layers.append(
            pdk.Layer(
                'PathLayer',
                data=route_data,
                get_path='path',
                get_color='[239, 68, 68, 200]', # Bright red for the route
                get_width=5,
                width_scale=1,
                width_min_pixels=2,
                pickable=True,
            )
        )

    # Return PyDeck object
    return pdk.Deck(
        initial_view_state=view_state,
        layers=layers,
        tooltip={"text": "{name}"}
        # map_style is removed as we are using BitmapLayer for the base map
    )

def build_truck_segments(simulation_log_df, network_df):
    """
    Transforms simulation log into a DataFrame of travel segments for animation.
    
    Args:
        simulation_log_df (pd.DataFrame): The DataFrame generated by the simulation.
        network_df (pd.DataFrame): The original network DataFrame with node coordinates.
        
    Returns:
        pd.DataFrame: A DataFrame suitable for PyDeck's TripsLayer or PathLayer.
                      Columns: truckId, type, path (list of [lon, lat]), startTime, endTime.
    """
    segments = []
    node_coords_map = network_df.set_index('node_id')[['lat', 'lon']].to_dict('index')

    for index, row in simulation_log_df.iterrows():
        from_coords = node_coords_map[row['from']]
        to_coords = node_coords_map[row['to']]
        
        segments.append({
            'truckId': row['truckId'],
            'type': row['type'],
            'path': [[from_coords['lon'], from_coords['lat']],
                     [to_coords['lon'], to_coords['lat']]],
            'startTime': row['arrival_time_hr'] - row['adjusted_travel_time_hr'], # Calculate start time of segment
            'endTime': row['arrival_time_hr']
        })
    return pd.DataFrame(segments)

def get_positions_at_time(segments_for_animation_df, current_time, network_df):
    """
    Calculates the interpolated positions of trucks at a given simulation time.
    
    Args:
        segments_for_animation_df (pd.DataFrame): DataFrame of segments for animation.
        current_time (float): The current simulation time (hours).
        network_df (pd.DataFrame): The original network DataFrame with node coordinates.

    Returns:
        list: List of dictionaries with 'id', 'type', 'lat', 'lon' for each truck.
    """
    truck_current_positions = []
    
    # Find all unique trucks
    unique_truck_ids = segments_for_animation_df['truckId'].unique()

    for truck_id in unique_truck_ids:
        truck_segments = segments_for_animation_df[segments_for_animation_df['truckId'] == truck_id]
        
        # Sort segments by start time
        truck_segments = truck_segments.sort_values(by='startTime').reset_index(drop=True)
        
        current_segment = None
        for idx, segment_row in truck_segments.iterrows():
            if current_time >= segment_row['startTime'] and current_time < segment_row['endTime']:
                current_segment = segment_row
                break
            elif current_time >= segment_row['endTime'] and (idx + 1 == len(truck_segments) or current_time < truck_segments.iloc[idx+1]['startTime']):
                # If current time is past this segment's end but before next segment's start (or is last segment)
                # the truck is at the 'to' node of this segment.
                current_segment = segment_row
                # Force position to end of segment if simulation_time is past it
                truck_current_positions.append({
                    'id': truck_id,
                    'type': segment_row['type'],
                    'lat': segment_row['coordinates'][1][1], # End Lat (using 'coordinates' key)
                    'lon': segment_row['coordinates'][1][0]  # End Lon (using 'coordinates' key)
                })
                break # Found position, move to next truck

        if current_segment is not None:
            # CORRECTED LINE: Access the list from the Series using .item() and the correct key 'coordinates'
            segment_path_coords = current_segment['coordinates'].item() if isinstance(current_segment['coordinates'], pd.Series) else current_segment['coordinates']

            from_lon, from_lat = segment_path_coords[0]
            to_lon, to_lat = segment_path_coords[1]
            
            segment_duration = current_segment['endTime'] - current_segment['startTime']

            if segment_duration > 0:
                progress = (current_time - current_segment['startTime']) / segment_duration
                # Clamp progress between 0 and 1
                progress = max(0, min(1, progress))

                current_lon = from_lon + (to_lon - from_lon) * progress
                current_lat = from_lat + (to_lat - from_lat) * progress
            else: # Instantaneous movement or start of simulation
                current_lon, current_lat = from_lon, from_lat
            
            # Avoid adding duplicate if already added by 'past segment' logic
            if not any(t['id'] == truck_id for t in truck_current_positions):
                truck_current_positions.append({
                    'id': truck_id,
                    'type': current_segment['type'],
                    'lat': current_lat,
                    'lon': current_lon
                })
        else:
            # If current_time is before the first segment, place at the start node (DC)
            # Or if current_time is after all segments, place at the final node
            if current_time < truck_segments['startTime'].min() if not truck_segments.empty else 0:
                 # Place at the starting DC for this truck's route (first node in global route)
                 # Find the starting DC's coordinates
                 dc_node_id = network_df[network_df['type'] == 'dc']['node_id'].iloc[0] # Assuming first DC
                 start_node_coords = network_df[network_df['node_id'] == dc_node_id].iloc[0]
                 
                 truck_current_positions.append({
                    'id': truck_id,
                    'type': truck_segments['type'].iloc[0] if not truck_segments.empty else 'EV',
                    'lat': start_node_coords['lat'],
                    'lon': start_node_coords['lon']
                })
            elif current_time > truck_segments['endTime'].max() if not truck_segments.empty else 0:
                 # Place at the very last node of its route
                 final_segment = truck_segments.iloc[-1]
                 # Ensure final_segment['coordinates'] is treated as a list
                 final_path_coords = final_segment['coordinates'].item() if isinstance(final_segment['coordinates'], pd.Series) else final_segment['coordinates']

                 truck_current_positions.append({
                    'id': truck_id,
                    'type': final_segment['type'],
                    'lat': final_path_coords[1][1], # End Lat
                    'lon': final_path_coords[1][0]  # End Lon
                })
            # Else (e.g., time falls between gaps in segments for some reason, or no segments) - do nothing

    return truck_current_positions

